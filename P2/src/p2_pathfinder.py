from math import inf, sqrtfrom heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    # Calculates if the point is in the given box    def inRectangle(box, point):        x1, x2, y1, y2 = box        ax, ay = point        return (ax > x1 and ax < x2 and ay > y1 and ay < y2)    # Finds the box the point is in    def findBox(point):        for box in mesh['boxes']:            if inRectangle(box, point) and box not in boxes:                return box    # Finds the euclidian distance    def euclidian(a, b):        return sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2) * 0.5        # The priority queue    source_box = findBox(source_point)    destination_box = findBox(destination_point)    queue = [(0,source_box)]    # The dictionary that will be returned with the costs    distances = {}    distances[source_box] = 0    # The dictionary that will store the backpointers    backpointers = {}    backpointers[source_box] = None    # The dictionary that will store the coordinates of each backpointer    box_coord = {}    box_coord[source_box] = source_point        while queue:        current_dist, current_box = heappop(queue)        # Check if current box is the destination box        if current_box == destination_box:            # List containing all coordinates from initial_position to destination            path = [[box_coord[current_box], destination_point]]            # Go backwards from destination until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_box = backpointers[current_box]            current_back_coord = box_coord[current_box]            while current_back_box is not None:                path.insert(0,[box_coord[current_back_box], current_back_coord])                current_back_coord = box_coord[current_back_box]                current_back_box = backpointers[current_back_box]            return path, boxes.keys()        # Calculate cost from current box to all the adjacent ones        for adj_box in mesh['adj'][current_box]:            boxes[adj_box] = current_box            # Finds edge range            x_range = [max(current_box[0], adj_box[0]),min(current_box[1], adj_box[1])]            y_range = [max(current_box[2], adj_box[2]),min(current_box[3], adj_box[3])]            # Mid point of edge range            mid = [(x_range[0] + x_range[1]) * 0.5, (y_range[0] + y_range[1]) * 0.5]             # Calculates cost from each edge point            a_cost = euclidian((x_range[0],y_range[0]), box_coord[current_box]) + euclidian(destination_point, (x_range[0],y_range[0]))            b_cost = euclidian((x_range[1],y_range[1]), box_coord[current_box]) + euclidian(destination_point, (x_range[1],y_range[1]))            mid_cost = euclidian((mid[0],mid[1]), box_coord[current_box]) + euclidian(destination_point, (mid[0],mid[1]))            # Lowest cost is added to the queue            if a_cost <= b_cost and a_cost <= mid_cost:                edge_cost = a_cost                edge_point = (x_range[0],y_range[0])            elif b_cost < a_cost and b_cost <= mid_cost:                edge_cost = b_cost                edge_point = (x_range[1],y_range[1])            elif mid_cost < a_cost and mid_cost < b_cost:                edge_cost = mid_cost                edge_point = (mid[0],mid[1])            # If the cost is new            pathcost = current_dist + edge_cost            if adj_box not in distances or pathcost < distances[adj_box]:                distances[adj_box] = pathcost                backpointers[adj_box] = current_box                box_coord[adj_box] = edge_point                heappush(queue, (pathcost, adj_box))    return None